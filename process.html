<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Fashion_MNIST_Project - Process Data</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="Fashion_MNIST_Project - Process Data">
<meta property="og:description" content="">
<meta property="og:image" content="https://nvtai040502.github.io/Fashion_MNIST_Project/00_process_files/figure-html/cell-5-output-1.png">
<meta property="og:site-name" content="Fashion_MNIST_Project">
<meta property="og:image:height" content="531">
<meta property="og:image:width" content="1105">
<meta name="twitter:title" content="Fashion_MNIST_Project - Process Data">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://nvtai040502.github.io/Fashion_MNIST_Project/00_process_files/figure-html/cell-5-output-1.png">
<meta name="twitter:image-height" content="531">
<meta name="twitter:image-width" content="1105">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Fashion MNIST</span>
    </a>
  </div>
        <div class="quarto-navbar-tools ms-auto">
    <a href="https://github.com/nvtai040502" rel="" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./process.html">Process Data</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Project Fashion MNIST</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./process.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Process Data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./linearlayer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Linear Layer</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./neuralnet.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Neural Network</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./regularization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Regularization</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cnn.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CNN</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./finetuning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Fine Tuning</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#about-fashion-mnist" id="toc-about-fashion-mnist" class="nav-link active" data-scroll-target="#about-fashion-mnist">About Fashion MNIST</a></li>
  <li><a href="#split-data" id="toc-split-data" class="nav-link" data-scroll-target="#split-data">Split data</a></li>
  <li><a href="#normalization" id="toc-normalization" class="nav-link" data-scroll-target="#normalization">Normalization</a></li>
  <li><a href="#load-data" id="toc-load-data" class="nav-link" data-scroll-target="#load-data">Load Data</a></li>
  <li><a href="#altogether" id="toc-altogether" class="nav-link" data-scroll-target="#altogether">Altogether</a></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/nvtai040502/Fashion_MNIST_Project/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Process Data</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<section id="about-fashion-mnist" class="level2">
<h2 class="anchored" data-anchor-id="about-fashion-mnist">About Fashion MNIST</h2>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torchvision</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torchvision <span class="im">import</span> datasets</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Download Data</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>train_dataset <span class="op">=</span> datasets.FashionMNIST(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">True</span>, download<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>test_dataset <span class="op">=</span> datasets.FashionMNIST(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">False</span>, download<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the lengths of the datasets</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of samples in the training set:"</span>, <span class="bu">len</span>(train_dataset))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of samples in the test set:"</span>, <span class="bu">len</span>(test_dataset))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Number of samples in the training set: 60000
Number of samples in the test set: 10000</code></pre>
</div>
</div>
<p>Fashion MNIST là một bộ dữ liệu chứa các hình ảnh về sản phẩm thời trang từ Zalando, bao gồm một bộ dữ liệu huấn luyện (training set) với 60,000 ví dụ và một bộ dữ liệu kiểm tra (test set) với 10,000 ví dụ.</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> train_dataset.data</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Shape: </span><span class="sc">{</span>x<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Min: </span><span class="sc">{</span>x<span class="sc">.</span><span class="bu">min</span>()<span class="sc">.</span>item()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Max: </span><span class="sc">{</span>x<span class="sc">.</span><span class="bu">max</span>()<span class="sc">.</span>item()<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Shape: torch.Size([60000, 28, 28])
Min: 0
Max: 255</code></pre>
</div>
</div>
<p>Mỗi hình ảnh có chiều cao 28 pixel và chiều rộng 28 pixel, tổng cộng có 784 pixel. Giá trị pixel này là một số nguyên nằm trong khoảng từ 0 đến 255.</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># constant for classes</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>classes <span class="op">=</span> [<span class="st">'T-shirt/top'</span>, <span class="st">'Trouser'</span>, <span class="st">'Pullover'</span>, <span class="st">'Dress'</span>, <span class="st">'Coat'</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Sandal'</span>, <span class="st">'Shirt'</span>, <span class="st">'Sneaker'</span>, <span class="st">'Bag'</span>, <span class="st">'Ankle Boot'</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> train_dataset.targets</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Labels: </span><span class="sc">{</span>y<span class="sc">.</span>unique()<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Labels: tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre>
</div>
</div>
<p>Mỗi ví dụ trong bộ dữ liệu huấn luyện và bộ dữ liệu kiểm tra được gán cho một trong các nhãn (label) sau:</p>
<ul>
<li><p>0 Áo phông/T-shirt</p></li>
<li><p>1 Quần dài/Trouser</p></li>
<li><p>2 Áo khoác len/Pullover</p></li>
<li><p>3 Váy/Dress</p></li>
<li><p>4 Áo khoác/Coat</p></li>
<li><p>5 Dép xỏ ngón/Sandal</p></li>
<li><p>6 Áo sơ mi/Shirt</p></li>
<li><p>7 Giày thể thao/Sneaker</p></li>
<li><p>8 Túi xách/Bag</p></li>
<li><p>9 Giày bốt/Cổ cao/Ankle boot</p></li>
</ul>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">8</span>, figsize <span class="op">=</span> (<span class="dv">14</span>, <span class="dv">6</span>))</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax <span class="kw">in</span> axs.flatten():</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    random_index <span class="op">=</span> np.random.randint(<span class="bu">len</span>(x))</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    ax.imshow(x[random_index, :], cmap <span class="op">=</span> <span class="st">"gray"</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f"</span><span class="sc">{</span>classes[y[random_index].item()]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">"off"</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Training data"</span>, fontsize <span class="op">=</span> <span class="dv">18</span>)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="00_process_files/figure-html/cell-5-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="split-data" class="level2">
<h2 class="anchored" data-anchor-id="split-data">Split data</h2>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>labels, counts <span class="op">=</span> np.unique(y, return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Checking Data Balance:"</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label, count <span class="kw">in</span> <span class="bu">zip</span>(labels, counts):</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Label: </span><span class="sc">{</span>label<span class="sc">}</span><span class="ss">, Count: </span><span class="sc">{</span>count<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Checking Data Balance:
 Label: 0, Count: 6000
 Label: 1, Count: 6000
 Label: 2, Count: 6000
 Label: 3, Count: 6000
 Label: 4, Count: 6000
 Label: 5, Count: 6000
 Label: 6, Count: 6000
 Label: 7, Count: 6000
 Label: 8, Count: 6000
 Label: 9, Count: 6000</code></pre>
</div>
</div>
<p>Dữ liệu đã được cân bằng hoàn hảo, với mỗi nhãn (label) chứa đúng 6000 mẫu dữ liệu.</p>
<p>Để hiểu điều này, hãy xem xét một ví dụ tương tự trong cuộc thi có 10 câu hỏi với 4 phương án trả lời A, B, C, D. Trong tình huống này, số câu trả lời đúng cho mỗi phương án là 8 câu A, 1 câu B, 0 câu C và 1 câu D.</p>
<p>Giả sử bạn được phép làm cuộc thi này nhiều lần. Sau một thời gian, bạn sẽ nhận thấy một sự thiên vị trong số câu trả lời đúng cho mỗi phương án. Điều này có nghĩa rằng câu A thường là câu trả lời đúng và bạn có thể dễ dàng chọn câu A cho tất cả các câu hỏi để đạt điểm số cao.</p>
<p>Tương tự như vậy, trong việc kiểm tra độ cân bằng của dữ liệu, chúng ta đảm bảo rằng mô hình deep learning được đào tạo trên dữ liệu mẫu đại diện cho tất cả các trường hợp, thay vì bị thiên vị theo một phương án hoặc lớp cụ thể. Điều này giúp đảm bảo tính công bằng và độ chính xác của mô hình trong ứng dụng thực tế.</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Split the data into training and validation sets</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the number of validation samples per label</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>num_labels <span class="op">=</span> <span class="bu">len</span>(np.unique(y))</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>val_pct <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>val_samples_per_label <span class="op">=</span> <span class="bu">int</span>(<span class="bu">len</span>(x) <span class="op">*</span> val_pct <span class="op">/</span> num_labels)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>valid_indices <span class="op">=</span> []</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Iterate through each unique label</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label <span class="kw">in</span> np.unique(y):</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get the indices of samples belonging to this label</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    label_indices <span class="op">=</span> np.where(y <span class="op">==</span> label)[<span class="dv">0</span>]</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Randomly select a specified number of validation samples from this label</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    sampled_indices <span class="op">=</span> np.random.choice(label_indices, val_samples_per_label, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    valid_indices.append(sampled_indices)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>excluded_indices <span class="op">=</span> np.concatenate(valid_indices)</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> np.ones(<span class="bu">len</span>(x), dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>mask[excluded_indices] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Separate the data into training and validation sets</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>x_train <span class="op">=</span> x[mask]</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>x_valid <span class="op">=</span> x[excluded_indices]</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>y_train <span class="op">=</span> y[mask]</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>y_valid <span class="op">=</span> y[excluded_indices]</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the shapes of the training and validation sets</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>x_train.shape, y_train.shape, x_valid.shape, y_valid.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>(torch.Size([48000, 28, 28]),
 torch.Size([48000]),
 torch.Size([12000, 28, 28]),
 torch.Size([12000]))</code></pre>
</div>
</div>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>val_labels, counts <span class="op">=</span> np.unique(y_valid, return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Checking Valid Data Balance:"</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> val_label, count <span class="kw">in</span> <span class="bu">zip</span>(val_labels, counts):</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Label: </span><span class="sc">{</span>val_label<span class="sc">}</span><span class="ss">, Count: </span><span class="sc">{</span>count<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Checking Valid Data Balance:
 Label: 0, Count: 1200
 Label: 1, Count: 1200
 Label: 2, Count: 1200
 Label: 3, Count: 1200
 Label: 4, Count: 1200
 Label: 5, Count: 1200
 Label: 6, Count: 1200
 Label: 7, Count: 1200
 Label: 8, Count: 1200
 Label: 9, Count: 1200</code></pre>
</div>
</div>
<p>Trong quá trình phát triển mô hình deep learning, việc chia dữ liệu thành hai phần: tập huấn luyện (train set) và tập xác thực (validation set) , đồng thời duy trì sự cân bằng giữa các nhãn (labels) trong cả hai tập là rất quan trọng. Điều này tương tự như việc bạn ôn tập để chuẩn bị cho một kỳ thi</p>
<p>Hãy tưởng tượng bạn nhận được một đề cương ôn thi gồm 20 câu hỏi, trong đó mỗi câu có 4 phương án A, B, C, D và chỉ có một phương án đúng. Đề cương này đã được thiết kế sao cho cân bằng về số lượng câu trả lời đúng cho mỗi phương án. Trong trường hợp này, bạn có hai cách để ôn:</p>
<p><strong>Cách 1: Học thuộc lòng đáp án của đề cương</strong> Bạn có thể chọn học thuộc lòng đáp án cho từng câu hỏi trong đề cương. Tuy nhiên, khi tham gia kỳ thi thực tế, cách này thường dẫn đến điểm thấp, vì bạn có thể gặp những biến thể hoặc câu hỏi tương tự mà bạn chưa từng thấy trước đó. Bạn thiếu khả năng áp dụng kiến thức vào các tình huống mới và sâu hơn về nội dung thực sự của các câu hỏi.</p>
<p><strong>Cách 2: Học để hiểu cách trả lời câu hỏi một cách tổng quát</strong> Thay vì chỉ học thuộc lòng đáp án, bạn cố gắng hiểu sâu về kiến thức và logic đằng sau mỗi câu hỏi. Điều này giúp bạn phát triển khả năng áp dụng kiến thức vào các tình huống mới, bao gồm những biến thể của câu hỏi mà bạn có thể gặp trong kỳ thi thực tế. Khi tham gia kỳ thi, bạn sẽ tự tin hơn và có khả năng xử lý bất kỳ câu hỏi nào, giúp bạn đạt được điểm cao hơn.</p>
<p>Tương tự, việc chia dữ liệu thành tập huấn luyện và tập xác thực trong deep learning giúp mô hình học cách phân loại dữ liệu và tạo ra các dự đoán không chỉ dựa trên việc ghi nhớ dữ liệu huấn luyện. Nó giúp mô hình hiểu và tổng quát hóa kiến thức, từ đó cải thiện khả năng dự đoán trên dữ liệu mới và không biết trước (tập xác thực hoặc tập kiểm tra). Việc này giúp tránh overfitting, cải thiện hiệu suất của mô hình và làm cho nó trở nên đáng tin cậy hơn trong các ứng dụng thực tế.</p>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Split data into train &amp; valid set</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>valid_pct <span class="op">=</span> <span class="fl">.2</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>x_train, x_valid, y_train, y_valid <span class="op">=</span> train_test_split(x, y, test_size <span class="op">=</span> valid_pct)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(x_train.shape, y_train.shape, x_valid.shape, y_valid.shape)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>val_labels, counts <span class="op">=</span> np.unique(y_valid, return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Checking Valid Data Balance:"</span>)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> val_label, count <span class="kw">in</span> <span class="bu">zip</span>(val_labels, counts):</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Label: </span><span class="sc">{</span>val_label<span class="sc">}</span><span class="ss">, Count: </span><span class="sc">{</span>count<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([48000, 28, 28]) torch.Size([48000]) torch.Size([12000, 28, 28]) torch.Size([12000])
Checking Valid Data Balance:
 Label: 0, Count: 1206
 Label: 1, Count: 1273
 Label: 2, Count: 1219
 Label: 3, Count: 1190
 Label: 4, Count: 1163
 Label: 5, Count: 1176
 Label: 6, Count: 1197
 Label: 7, Count: 1173
 Label: 8, Count: 1210
 Label: 9, Count: 1193</code></pre>
</div>
</div>
<p>Ơn trời, train_test_split thực sự đã làm cuộc sống của chúng ta trở nên dễ dàng và hạnh phúc hơn rất nhiều! 😃</p>
</section>
<section id="normalization" class="level2">
<h2 class="anchored" data-anchor-id="normalization">Normalization</h2>
<p>Có ba phương pháp chuẩn hóa thường xuyên được sử dụng bao gồm:</p>
<ul>
<li><p>Min-Max Scaling</p></li>
<li><p>Z-Score (Standardization)</p></li>
<li><p>Robust Scaling.</p></li>
</ul>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_max_scale(data, a<span class="op">=</span><span class="dv">0</span>, b<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the minimum and maximum values of the data</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    data_min <span class="op">=</span> data.<span class="bu">min</span>()</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    data_max <span class="op">=</span> data.<span class="bu">max</span>()</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform Min-Max Scaling</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    data_norm <span class="op">=</span> (data <span class="op">-</span> data_min) <span class="op">/</span> (data_max <span class="op">-</span> data_min)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rescale the data to the [a, b] range</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    data_norm <span class="op">=</span> a <span class="op">+</span> data_norm <span class="op">*</span> (b <span class="op">-</span> a)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data_norm</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Công thức của Min-Max Scaling:</strong></p>
<p>Min-Max Scaling là một phương pháp chuẩn hóa dữ liệu được sử dụng để ánh xạ giá trị của một dữ liệu từ khoảng ban đầu [Min, Max] sang một khoảng mới [a, b], với a và b là giá trị cụ thể.</p>
<p>Công thức để scale giá trị x của một dữ liệu từ khoảng ban đầu [Min, Max] sang khoảng [0, 1] là:</p>
<p><span class="math display">\[ \text{Scaled Value} = \frac{{\text{x} - \text{Min}}}{{\text{Max} - \text{Min}}} \]</span></p>
<p>Để scale giá trị x của một dữ liệu về khoảng [a, b], công thức sẽ là:</p>
<p><span class="math display">\[ \text{Scaled Value} = a + \frac{{\text{x} - \text{Min}}}{{\text{Max} - \text{Min}}} \cdot (b - a) \]</span></p>
<p>Trong đó:</p>
<ul>
<li><p><strong>Scale Value</strong>: Giá trị sau khi chuẩn hóa của dữ liệu theo phương pháp Min-Max Scaling.</p></li>
<li><p><strong>x</strong>: Giá trị ban đầu của dữ liệu.</p></li>
<li><p><strong>Min</strong>: Giá trị nhỏ nhất trong khoảng ban đầu.</p></li>
<li><p><strong>Max</strong>: Giá trị lớn nhất trong khoảng ban đầu.</p></li>
<li><p><strong>a</strong>: Giá trị nhỏ nhất trong khoảng mới (thường là 0).</p></li>
<li><p><strong>b</strong>: Giá trị lớn nhất trong khoảng mới (thường là 1).</p></li>
</ul>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> z_score(data):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the mean and standard deviation of the input data</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    data_mean <span class="op">=</span> data.mean()</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    data_std <span class="op">=</span> data.std(ddof<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform Z-score (standardization) on the data</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    data_norm <span class="op">=</span> (data <span class="op">-</span> data_mean) <span class="op">/</span> data_std</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data_norm</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Công thức của Z-score (Standardization):</strong></p>
<p>Z-score (hoặc Standardization) là một phương pháp chuẩn hóa dữ liệu được sử dụng để biến đổi giá trị của một dữ liệu sao cho nó có giá trị trung bình (mean) bằng 0 và độ lệch chuẩn (standard deviation) bằng 1.</p>
<p>Công thức để tính Z-score cho một giá trị x trong dữ liệu là:</p>
<p><span class="math display">\[ \text{Z-score} = \frac{{\text{x} - \text{Mean}}}{{\text{Standard Deviation}}} \]</span></p>
<p>Trong đó:</p>
<ul>
<li><p><strong>Z-score</strong>: Giá trị Z-score của dữ liệu sau khi chuẩn hóa.</p></li>
<li><p><strong>x</strong>: Giá trị ban đầu của dữ liệu.</p></li>
<li><p><strong>Mean</strong>: Giá trị trung bình của dữ liệu.</p></li>
<li><p><strong>Standard Deviation</strong>: Độ lệch chuẩn của dữ liệu.</p></li>
</ul>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> robust_scale(data):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the median and interquartile range (IQR) of the data</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    data_median <span class="op">=</span> np.median(data)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    iqr <span class="op">=</span> np.percentile(data, <span class="dv">75</span>) <span class="op">-</span> np.percentile(data, <span class="dv">25</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform Robust Scaling</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    data_scaled <span class="op">=</span> (data <span class="op">-</span> data_median) <span class="op">/</span> iqr</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data_scaled</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Công thức của Robust Scaling:</strong></p>
<p>Robust Scaling (hoặc Robust Standardization) là một phương pháp chuẩn hóa dữ liệu được sử dụng để biến đổi giá trị của một dữ liệu sao cho nó có tính ổn định đối với sự hiện diện của các outliers. Phương pháp này sử dụng median và khoảng biến thiên (IQR - Interquartile Range) của dữ liệu để thực hiện chuẩn hóa.</p>
<p>Công thức để tính Robust Scaling cho một giá trị x trong dữ liệu là:</p>
<p><span class="math display">\[ \text{Robust Scaled} = \frac{{\text{x} - \text{Median}}}{{\text{IQR}}} \]</span></p>
<p>Trong đó:</p>
<ul>
<li><p><strong>Robust Scaled</strong>: Giá trị sau khi chuẩn hóa của dữ liệu theo phương pháp Robust Scaling.</p></li>
<li><p><strong>x</strong>: Giá trị ban đầu của dữ liệu.</p></li>
<li><p><strong>Median</strong>: Giá trị trung vị (median) của dữ liệu.</p></li>
<li><p><strong>IQR</strong>: Khoảng biến thiên giữa phân vị 25% (Q1) và phân vị 75% (Q3) của dữ liệu.</p></li>
</ul>
<p><strong>Lựa chọn phương pháp normalization</strong></p>
<p>Việc lựa chọn phương pháp chuẩn hóa dữ liệu phụ thuộc vào tính chất của dữ liệu và mục tiêu cụ thể của dự án. Trong trường hợp dự án Fashion MNIST, dữ liệu là hình ảnh, do đó tôi đã chọn thử nghiệm <strong>hai</strong> phương pháp chuẩn hóa: <strong>Min-Max Scaling</strong> và <strong>Robust Scaling</strong>.</p>
<p>Lý do là Min-Max Scaling đơn giản chỉ định khoảng giá trị cho dữ liệu mà không thay đổi tính chất của hình ảnh ban đầu. Robust Scaling cũng phù hợp vì nó sử dụng median thay vì giá trị trung bình, nên nó có khả năng xử lý tốt với các bộ dữ liệu không tuân theo phân phối Gaussian. Tuy nhiên, Z-Score sử dụng mean nên không phải lúc nào cũng phù hợp cho các dữ liệu không tuân theo phân phối Gaussian.</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>x_train_norm <span class="op">=</span> min_max_scale(x_train)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>x_valid_norm <span class="op">=</span> min_max_scale(x_valid)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Train Data: </span><span class="sc">{</span>x_train_norm<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">, Min: </span><span class="sc">{</span>x_train_norm<span class="sc">.</span><span class="bu">min</span>()<span class="sc">}</span><span class="ss">, Max: </span><span class="sc">{</span>x_train_norm<span class="sc">.</span><span class="bu">max</span>()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Valid Data: </span><span class="sc">{</span>x_valid_norm<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">, Min: </span><span class="sc">{</span>x_valid_norm<span class="sc">.</span><span class="bu">min</span>()<span class="sc">}</span><span class="ss">, Max: </span><span class="sc">{</span>x_valid_norm<span class="sc">.</span><span class="bu">max</span>()<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Train Data: torch.Size([48000, 28, 28]), Min: 0.0, Max: 1.0
Valid Data: torch.Size([12000, 28, 28]), Min: 0.0, Max: 1.0</code></pre>
</div>
</div>
<p>Trước hết, tôi sẽ bắt đầu bằng việc chuẩn hóa dữ liệu bằng phương pháp Min-Max Scaling. Sau đó, khi tiến đến giai đoạn tối ưu hóa mô hình để tăng độ chính xác trong việc dự đoán dữ liệu xác thực (Validation Data), tôi sẽ quay lại và thử nghiệm với Robust Scaling để xem liệu có cải thiện độ chính xác của mô hình hay không.</p>
</section>
<section id="load-data" class="level2">
<h2 class="anchored" data-anchor-id="load-data">Load Data</h2>
<p>Trong quá trình tải dữ liệu và huấn luyện mô hình Deep Learning, có ba khái niệm quan trọng cần hiểu:</p>
<ul>
<li><p><strong>Batches:</strong></p></li>
<li><p><strong>Mini-Batches:</strong></p></li>
<li><p><strong>Stochastic Gradient Descent (SGD)</strong>:</p></li>
</ul>
<p>Lựa chọn giữa Batches, Mini-Batches và SGD phụ thuộc vào tài nguyên và mục tiêu huấn luyện của bạn. Chúng có ảnh hưởng đến tốc độ học của mô hình và khả năng tổng quát hóa.</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> load_data(x_tensor, y_tensor, batch_size, drop_last<span class="op">=</span><span class="va">False</span>, test<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    num_samples <span class="op">=</span> <span class="bu">len</span>(x_tensor)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    mini_batches <span class="op">=</span> []</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> test:</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Shuffle the data if it's the training set</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        indices <span class="op">=</span> np.arange(num_samples)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        np.random.shuffle(indices)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        x_tensor <span class="op">=</span> x_tensor[indices]</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        y_tensor <span class="op">=</span> y_tensor[indices]</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, num_samples, batch_size):</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Handling the last mini-batch</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">+</span> batch_size <span class="op">&gt;</span> num_samples:</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If not dropping the last mini-batch</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> drop_last:</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>                batch_x <span class="op">=</span> x_tensor[i:num_samples]</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>                batch_y <span class="op">=</span> y_tensor[i:num_samples]</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For other mini-batches</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>            batch_x <span class="op">=</span> x_tensor[i:i <span class="op">+</span> batch_size]</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>            batch_y <span class="op">=</span> y_tensor[i:i <span class="op">+</span> batch_size]</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>        mini_batches.append((batch_x, batch_y))</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total Mini-Batches: </span><span class="sc">{</span><span class="bu">len</span>(mini_batches)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (x, y) <span class="kw">in</span> <span class="bu">enumerate</span>(mini_batches):</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Shape of Each Mini-Batch: </span><span class="sc">{</span>x<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">""</span>)</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mini_batches</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Batches (batch_size = length of data)</span></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>train_batch_size <span class="op">=</span> <span class="bu">len</span>(x_train_norm)</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>valid_batch_size <span class="op">=</span> <span class="bu">len</span>(x_valid_norm)</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>train_loader <span class="op">=</span> load_data(x_train_norm, y_train, batch_size<span class="op">=</span>train_batch_size)</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>valid_loader <span class="op">=</span> load_data(x_valid_norm, y_valid, batch_size<span class="op">=</span>valid_batch_size, test<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total Mini-Batches: 1
Shape of Each Mini-Batch: torch.Size([48000, 28, 28])

Total Mini-Batches: 1
Shape of Each Mini-Batch: torch.Size([12000, 28, 28])
</code></pre>
</div>
</div>
<p><strong>Batches</strong>: Khi bạn tải toàn bộ dữ liệu vào mô hình để tính gradient và cập nhật trọng số, chúng ta gọi đó là <em>Batches.</em></p>
<blockquote class="blockquote">
<p>Trong Batches, toàn bộ dữ liệu được sử dụng một lần duy nhất trong mỗi vòng lặp huấn luyện. Trong trường hợp này, <strong>batch size</strong> bằng với chiều dài của dữ liệu.</p>
</blockquote>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Mini Batches </span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>train_batch_size <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>valid_batch_size <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>train_loader <span class="op">=</span> load_data(x_train_norm, y_train, batch_size<span class="op">=</span>train_batch_size, drop_last<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>valid_loader <span class="op">=</span> load_data(x_valid_norm, y_valid, batch_size<span class="op">=</span>valid_batch_size, test<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total Mini-Batches: 750
Shape of Each Mini-Batch: torch.Size([64, 28, 28])

Total Mini-Batches: 375
Shape of Each Mini-Batch: torch.Size([32, 28, 28])
</code></pre>
</div>
</div>
<p><strong>Mini Batches</strong>: Khi bạn tải một phần nhỏ của dữ liệu, với kích thước nằm giữa một mẫu đơn và toàn bộ dữ liệu, chúng ta gọi đó là <em>Mini-Batches.</em></p>
<blockquote class="blockquote">
<p>Trong Mini-Batches, bạn chia dữ liệu thành các nhóm nhỏ có kích thước cố định, gọi là <strong>“batch size”</strong>. Mỗi batch trong đó chứa một số lượng mẫu dữ liệu được sử dụng để tính gradient và cập nhật trọng số.</p>
</blockquote>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># SGD (batch_size = 1)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>train_batch_size <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>valid_batch_size <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>train_loader <span class="op">=</span> load_data(x_train_norm, y_train, batch_size<span class="op">=</span>train_batch_size)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>valid_loader <span class="op">=</span> load_data(x_valid_norm, y_valid, batch_size<span class="op">=</span>valid_batch_size, test<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total Mini-Batches: 48000
Shape of Each Mini-Batch: torch.Size([1, 28, 28])

Total Mini-Batches: 12000
Shape of Each Mini-Batch: torch.Size([1, 28, 28])
</code></pre>
</div>
</div>
<p><strong>SGD</strong>: là một phiên bản đặc biệt của mini-batches với <strong>batch size</strong> bằng 1, nghĩa là mỗi mẫu dữ liệu đều được sử dụng để tính gradient và cập nhật trọng số mô hình riêng lẻ.</p>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Mini Batches </span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>train_batch_size <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>valid_batch_size <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>train_loader <span class="op">=</span> load_data(x_train_norm, y_train, batch_size<span class="op">=</span>train_batch_size, drop_last<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>valid_loader <span class="op">=</span> load_data(x_valid_norm, y_valid, batch_size<span class="op">=</span>valid_batch_size, test<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total Mini-Batches: 375
Shape of Each Mini-Batch: torch.Size([128, 28, 28])

Total Mini-Batches: 94
Shape of Each Mini-Batch: torch.Size([128, 28, 28])
</code></pre>
</div>
</div>
<p><strong>Lựa chọn phương pháp</strong></p>
<p>Đối với dự án này, và thực tế là hầu hết các dự án khác, việc sử dụng <strong>Mini-Batches</strong> là phương pháp phổ biến và khả thi. Lý do là Mini-Batches cho phép tận dụng sức mạnh của <strong>GPU</strong> và giúp tiết kiệm đáng kể thời gian huấn luyện mô hình. Do đó, quá trình load data cũng trở thành một phần quan trọng và không thể thiếu trong quá trình xây dựng mô hình Deep Learning.</p>
<p>Trong tập dữ liệu huấn luyện (train set), việc trộn (shuffle) dữ liệu là bước không thể thiếu để mô hình học một cách tổng quan hơn, như việc khuấy đều mọi thứ trước khi nấu một món ngon. Trong phương pháp Mini-Batches, việc quyết định có nên loại bỏ dữ liệu cuối cùng (drop_last) hay không phụ thuộc vào số lượng mẫu dữ liệu có sẵn trong dự án của bạn. Với dự án này có 60000 mẫu dữ liệu, việc loại bỏ một lượng nhỏ ở mini-batches cuối cùng không ảnh hưởng đáng kể đến sự hiệu quả của mô hình.</p>
<p>Tuy nhiên, đối với tập dữ liệu kiểm tra, bạn không cần phải lo lắng về việc trộn dữ liệu hoặc suy nghĩ về việc có bỏ dữ liệu ở mini-batches cuối cùng hay không. Đơn giản là bạn cứ tải nó vào các Mini-Batches để tối ưu hóa tính toán cho mô hình, như việc thưởng thức một bữa ăn ngon mà không cần phải nấu lại từ đầu.</p>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> TensorDataset, DataLoader</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> load_data(x_tensor, y_tensor, batch_size, test):</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> TensorDataset(x_tensor, y_tensor)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    data_loader <span class="op">=</span> DataLoader(data, batch_size<span class="op">=</span>batch_size, shuffle<span class="op">=</span><span class="kw">not</span> test, drop_last<span class="op">=</span><span class="kw">not</span> test)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total Mini-Batches: </span><span class="sc">{</span><span class="bu">len</span>(data_loader)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (x, y) <span class="kw">in</span> <span class="bu">enumerate</span>(data_loader):</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Shape of Each Mini-Batch: </span><span class="sc">{</span>x<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">""</span>)</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data_loader</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>train_loader <span class="op">=</span> load_data(x_train_norm, y_train, batch_size<span class="op">=</span>batch_size, test <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>valid_loader <span class="op">=</span> load_data(x_valid_norm, y_valid, batch_size<span class="op">=</span>batch_size, test<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total Mini-Batches: 375
Shape of Each Mini-Batch: torch.Size([128, 28, 28])

Total Mini-Batches: 94
Shape of Each Mini-Batch: torch.Size([128, 28, 28])
</code></pre>
</div>
</div>
<p>Giờ đây, quá trình tải dữ liệu (load data) trở nên cực kỳ đơn giản. Chỉ cần đưa x và y vào TensorDataset, sau đó sử dụng DataLoader với một số tùy chỉnh cho tập dữ liệu huấn luyện và kiểm tra, và bạn đã có mọi thứ cần thiết cho việc load data. Thật tuyệt vời!” 😄</p>
</section>
<section id="altogether" class="level2">
<h2 class="anchored" data-anchor-id="altogether">Altogether</h2>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Download Data</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torchvision <span class="im">import</span> datasets</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>train_dataset <span class="op">=</span> datasets.FashionMNIST(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">True</span>, download<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>test_dataset <span class="op">=</span> datasets.FashionMNIST(root<span class="op">=</span><span class="st">'./data'</span>, train<span class="op">=</span><span class="va">False</span>, download<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the lengths of the datasets</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of samples in the training set:"</span>, <span class="bu">len</span>(train_dataset))</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of samples in the test set:"</span>, <span class="bu">len</span>(test_dataset))</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">""</span>)</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a><span class="co"># constant for classes</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>classes <span class="op">=</span> [<span class="st">'T-shirt/top'</span>, <span class="st">'Trouser'</span>, <span class="st">'Pullover'</span>, <span class="st">'Dress'</span>, <span class="st">'Coat'</span>,</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Sandal'</span>, <span class="st">'Shirt'</span>, <span class="st">'Sneaker'</span>, <span class="st">'Bag'</span>, <span class="st">'Ankle Boot'</span>]</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> train_dataset.data</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> train_dataset.targets</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Shape: </span><span class="sc">{</span>x<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Min: </span><span class="sc">{</span>x<span class="sc">.</span><span class="bu">min</span>()<span class="sc">.</span>item()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Max: </span><span class="sc">{</span>x<span class="sc">.</span><span class="bu">max</span>()<span class="sc">.</span>item()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Labels: </span><span class="sc">{</span>y<span class="sc">.</span>unique()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">""</span>)</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Split data into train &amp; valid set</span></span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>valid_pct <span class="op">=</span> <span class="fl">.2</span></span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>x_train, x_valid, y_train, y_valid <span class="op">=</span> train_test_split(x, y, test_size <span class="op">=</span> valid_pct)</span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(x_train.shape, y_train.shape, x_valid.shape, y_valid.shape)</span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>val_labels, counts <span class="op">=</span> np.unique(y_valid, return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Checking Valid Data Balance:"</span>)</span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> val_label, count <span class="kw">in</span> <span class="bu">zip</span>(val_labels, counts):</span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Label: </span><span class="sc">{</span>val_label<span class="sc">}</span><span class="ss">, Count: </span><span class="sc">{</span>count<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Normalization </span></span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_max_scale(data, a<span class="op">=</span><span class="dv">0</span>, b<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the minimum and maximum values of the data</span></span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true" tabindex="-1"></a>    data_min <span class="op">=</span> data.<span class="bu">min</span>()</span>
<span id="cb31-44"><a href="#cb31-44" aria-hidden="true" tabindex="-1"></a>    data_max <span class="op">=</span> data.<span class="bu">max</span>()</span>
<span id="cb31-45"><a href="#cb31-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb31-46"><a href="#cb31-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform Min-Max Scaling</span></span>
<span id="cb31-47"><a href="#cb31-47" aria-hidden="true" tabindex="-1"></a>    data_norm <span class="op">=</span> (data <span class="op">-</span> data_min) <span class="op">/</span> (data_max <span class="op">-</span> data_min)</span>
<span id="cb31-48"><a href="#cb31-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb31-49"><a href="#cb31-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rescale the data to the [a, b] range</span></span>
<span id="cb31-50"><a href="#cb31-50" aria-hidden="true" tabindex="-1"></a>    data_norm <span class="op">=</span> a <span class="op">+</span> data_norm <span class="op">*</span> (b <span class="op">-</span> a)</span>
<span id="cb31-51"><a href="#cb31-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb31-52"><a href="#cb31-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data_norm</span>
<span id="cb31-53"><a href="#cb31-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-54"><a href="#cb31-54" aria-hidden="true" tabindex="-1"></a>x_train_norm <span class="op">=</span> min_max_scale(x_train)</span>
<span id="cb31-55"><a href="#cb31-55" aria-hidden="true" tabindex="-1"></a>x_valid_norm <span class="op">=</span> min_max_scale(x_valid)</span>
<span id="cb31-56"><a href="#cb31-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-57"><a href="#cb31-57" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">""</span>)</span>
<span id="cb31-58"><a href="#cb31-58" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Train Data: </span><span class="sc">{</span>x_train_norm<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">, Min: </span><span class="sc">{</span>x_train_norm<span class="sc">.</span><span class="bu">min</span>()<span class="sc">}</span><span class="ss">, Max: </span><span class="sc">{</span>x_train_norm<span class="sc">.</span><span class="bu">max</span>()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-59"><a href="#cb31-59" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Valid Data: </span><span class="sc">{</span>x_valid_norm<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">, Min: </span><span class="sc">{</span>x_valid_norm<span class="sc">.</span><span class="bu">min</span>()<span class="sc">}</span><span class="ss">, Max: </span><span class="sc">{</span>x_valid_norm<span class="sc">.</span><span class="bu">max</span>()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-60"><a href="#cb31-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">""</span>)</span>
<span id="cb31-61"><a href="#cb31-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-62"><a href="#cb31-62" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data</span></span>
<span id="cb31-63"><a href="#cb31-63" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> TensorDataset, DataLoader</span>
<span id="cb31-64"><a href="#cb31-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-65"><a href="#cb31-65" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> load_data(x_tensor, y_tensor, batch_size, test):</span>
<span id="cb31-66"><a href="#cb31-66" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> TensorDataset(x_tensor, y_tensor)</span>
<span id="cb31-67"><a href="#cb31-67" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb31-68"><a href="#cb31-68" aria-hidden="true" tabindex="-1"></a>    data_loader <span class="op">=</span> DataLoader(data, batch_size<span class="op">=</span>batch_size, shuffle<span class="op">=</span><span class="kw">not</span> test, drop_last<span class="op">=</span><span class="kw">not</span> test)</span>
<span id="cb31-69"><a href="#cb31-69" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb31-70"><a href="#cb31-70" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total Mini-Batches: </span><span class="sc">{</span><span class="bu">len</span>(data_loader)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-71"><a href="#cb31-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (x, y) <span class="kw">in</span> <span class="bu">enumerate</span>(data_loader):</span>
<span id="cb31-72"><a href="#cb31-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb31-73"><a href="#cb31-73" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Shape of Each Mini-Batch: </span><span class="sc">{</span>x<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-74"><a href="#cb31-74" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">""</span>)</span>
<span id="cb31-75"><a href="#cb31-75" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb31-76"><a href="#cb31-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data_loader</span>
<span id="cb31-77"><a href="#cb31-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-78"><a href="#cb31-78" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb31-79"><a href="#cb31-79" aria-hidden="true" tabindex="-1"></a>train_loader <span class="op">=</span> load_data(x_train_norm, y_train, batch_size<span class="op">=</span>batch_size, test <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb31-80"><a href="#cb31-80" aria-hidden="true" tabindex="-1"></a>valid_loader <span class="op">=</span> load_data(x_valid_norm, y_valid, batch_size<span class="op">=</span>batch_size, test<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Number of samples in the training set: 60000
Number of samples in the test set: 10000

Shape: torch.Size([60000, 28, 28])
Min: 0
Max: 255
Labels: tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

torch.Size([48000, 28, 28]) torch.Size([48000]) torch.Size([12000, 28, 28]) torch.Size([12000])
Checking Valid Data Balance:
 Label: 0, Count: 1186
 Label: 1, Count: 1200
 Label: 2, Count: 1187
 Label: 3, Count: 1146
 Label: 4, Count: 1226
 Label: 5, Count: 1203
 Label: 6, Count: 1204
 Label: 7, Count: 1179
 Label: 8, Count: 1262
 Label: 9, Count: 1207

Train Data: torch.Size([48000, 28, 28]), Min: 0.0, Max: 1.0
Valid Data: torch.Size([12000, 28, 28]), Min: 0.0, Max: 1.0

Total Mini-Batches: 375
Shape of Each Mini-Batch: torch.Size([128, 28, 28])

Total Mini-Batches: 94
Shape of Each Mini-Batch: torch.Size([128, 28, 28])
</code></pre>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>